 <h2>两数之和</h2>
两数之和 ^ea9401

t = 9 在 2，3，4，6，8 有序数组 (下标为1)中找
暴力做法 $O(n^2)$ 没有利用到有序的信息 ^8ed562

注意到
1. 2+8 >9 则  2 后的每一个数字 + 8 都大于 9 ，给数组首部和尾部各一个指针，数组尾部的指针从8指向6
2. 2+6<9,为了等于9，数组首部的指针需要移动到3
3. 3+6 = 9 算法结束

```python 
Class Solution:
	def twoSum(self,number:List[int],target[int]) -> List[int]:
		left = 0 
		right = len(number) - 1
		while True: #left < right 
			s = numbers[left] + numbers[right]
			if s == target:
				break
			if s > target:
				right -= 1
			else left += 1
		return [left+1,right+1] #下标从1开始
```

<h2>15 三数字之和</h2>
15.三数字之和 ^0e904f

给一个整数组`nums` 判断是否存在三元组，其中这三个数不同，但满足三个数相加等于0
需要返回所有的三元组且不重复

- `nums[i]+nums[j]+nums[k]=0`--> `nums[j]`+`nums[l]` = -`nums[i]` 转化为两数之和
- 数组顺序无所谓，可以先sort()
- 不包含重复的三元组，


```python
#@leet start 
Class Solution:
	def threeSum(self,nums:List[int]) -> List[List[int]]:
		nums.sort()
		ans = []
		n = len(nums)
		for i in range(n-2):
			x = nums[i]
			if i > 0 and x ==nums[i-1]:  
				continue
			if x + nums[i+1] + nums[i+2] > 0;
				break 
			if x + nums[-2] + nums[-1] <0;
				continue 
			j = i + 1
			k = n - 1
			while j < k 
				s = x + nums[j] + nums[k]
				if s > 0: 
					k -= 1
				elif s <0:
					j += 1
				else:
					ans.append([x,nums[j],nums[k]])
					j += 1
					while j < k and nums[j] == nums[j-1]
						j += 1
					k -= 1
					while k > j and nums[k] == nums[k+1]
						k -=1
		
		return ans 
						
			 
		
```


<h2>11.盛最多的雨水</h2>

盛最多的雨水 ^ed1c14